# Project_template

Это шаблон для решения проектной работы. Структура этого файла повторяет структуру заданий. Заполняйте его по мере работы над решением.

# Задание 1. Анализ и планирование

<aside>

Чтобы составить документ с описанием текущей архитектуры приложения, можно часть информации взять из описания компании и условия задания. Это нормально.

</aside>

### 1. Описание функциональности монолитного приложения

**Управление отоплением:**

- Пользователи могут удаленно включать/выключать отопление через веб-интерфейс.
- Взаимодействие с устройствами отопления (например, отправка команд на устройства).
- Основная бизнес-логика связана с обработкой команд от пользователя.


**Мониторинг температуры:**

- Система получает данные о температуре с датчиков, установленных в домах.
- Эти данные сохраняются в базе данных для последующего использования (например, истории или аналитики).
- Пользовательский интерфейс предоставляет пользователям возможность просматривать текущую температуру в реальном времени.


### 2. Анализ архитектуры монолитного приложения

### Сильные стороны:
- **Простота разработки и развертывания**:
    - Вся функциональность и обработка данных находятся в одном приложении.
    - Отсутствие распределенности, что упрощает взаимодействие сервисов.

- **Единая структура кода**:
    - Все компоненты (бизнес-логика, обработка запросов, управление данными) удобно интегрированы в одном репозитории.

### Слабые стороны:
- **Ограниченная масштабируемость**:
    - Приложение сложно масштабировать горизонтально (например, нагрузка на один из функциональных блоков влияет на всю систему).
    - Из-за высокой связанности (tight coupling) нельзя масштабировать только нужные компоненты.

- **Монолитность**:
    - Все компоненты объединены в единое приложение, что усложняет внесение изменений в функциональность и увеличивает риск регрессионных ошибок.

- **Сложное развертывание**:
    - Даже небольшое изменение требует полной остановки системы, поскольку приложение запускается в едином контейнере.

- **Нет разграничений по доменам**:
    - Нет четкого разделения на домены и их ответственности – код смешивает логику управления устройствами и мониторинг температуры.


### 3. Определение доменов и границы контекстов

С точки зрения **Domain-Driven Design (DDD)**, четко прослеживаются два основных **доменных контекста**:
1. **Управление устройствами (Devices Management)**:
    - Отвечает за:
        - Управление состоянием отопительных устройств (включение/выключение).
        - Планирование и выполнение команд для устройств.
        - Контроль статуса устройств.

2. **Мониторинг температуры (Temperature Monitoring)**:
    - Отвечает за:
        - Прием данных о температуре от датчиков.
        - Хранение данных в базе.
        - Предоставление данных пользователю через интерфейс.

### Границы контекстов:
Границы можно провести следующим образом:
- Каждому контексту можно выделить отдельную базу данных или таблицы, чтобы они были независимы.
- Общение между контекстами можно сделать через асинхронное сообщение или через API (зависит от характера взаимодействия).
- Например:
    1. Если данные от устройства отопления важны для мониторинга, сервис управления устройствами отправляет события о текущем состоянии в очередь сообщений, а сервис мониторинга их использует.
    2. Пользовательские операции связаны только с нужным контекстом (например, команды включения/выключения идут в контекст "Управления устройствами", а запросы температуры – в "Мониторинг температуры").

### **4. Проблемы монолитного решения**

1. **Масштабируемость:**
    - Невозможность независимого масштабирования компонентов
    - Сложность в обработке разной нагрузки на разные части системы

2. **Надёжность:**
    - Отказ одного компонента может привести к падению всей системы
    - Сложность изолирования проблем

3. **Развёртывание:**
    - Необходимость полной остановки системы при обновлении
    - Длительный процесс развёртывания

4. **Технологические ограничения:**
    - Привязка к единому стеку технологий
    - Сложность в интеграции новых технологий


Если вы считаете, что текущее решение не вызывает проблем, аргументируйте свою позицию.

### 5. Визуализация контекста системы — диаграмма С4

[Диаграмма контекстов C4](diagrams/context.puml)

# Задание 2. Проектирование микросервисной архитектуры

### . Выделенные микросервисы (To-Be):
1. **Device Management Service**:
    - Управление устройствами
    - Интеграция с устройствами через стандартные протоколы
    - Регистрация новых устройств

2. **Telemetry Service**:
    - Сбор данных с датчиков
    - Хранение исторических данных
    - Обработка телеметрии

3. **User Service**:
    - Управление пользователями
    - Аутентификация и авторизация
    - Управление доступом

4. **Scenario Service**:
    - Управление пользовательскими сценариями
    - Выполнение автоматизаций
    - Планирование действий

5. **API Gateway**:
    - Единая точка входа
    - Маршрутизация запросов
    - Безопасность и мониторинг


**Диаграмма контейнеров (Containers)**

[Диаграмма контейнеров](diagrams/containers.puml)

**Диаграмма компонентов (Components)**

[Диаграмма компонентов](diagrams/components.puml)

**Диаграмма кода (Code)**

[Диаграмма кода](diagrams/code.puml)

# Задание 3. Разработка ER-диаграммы

### 1. Сущности и атрибуты

| Сущность | Ключевые атрибуты | Назначение |
| --- | --- | --- |
| **User** | id (PK), email, password_hash, full_name, created_at, status | Учётная запись пользователя |
| **House** | id (PK), name, address, timezone, created_at | Дом/объект недвижимости |
| **UserHouse** | user_id (FK→User), house_id (FK→House), role, invited_at | Связь «пользователь–дом» (many-to-many) с ролью (owner, guest) |
| **Module** | id (PK), module_type_id (FK→ModuleType), house_id (FK→House), name, status, created_at | Логический «комплект» (отопление, свет, ворота…) установленный в конкретном доме |
| **ModuleType** | id (PK), code, name, description | Каталог типов модулей (Heating, Lighting, Gate, CCTV, …) |
| **Device** | id (PK), module_id (FK→Module), device_type_id (FK→DeviceType), serial_number, name, status, last_seen_at | Физическое устройство, входящее в модуль |
| **DeviceType** | id (PK), code, name, protocol, description | Каталог типов устройств (thermostat, relay, camera …) |
| **TelemetryData** | id (PK), device_id (FK→Device), ts (timestamp), key, value | Телеметрия и метаданные от устройств |
| **CommandLog** | id (PK), device_id (FK→Device), issued_at, command, payload, result_status | История отправленных команд (аудит) |
Дополнительные технические поля (version, updated_at и пр.) опущены для краткости.
### 2. Связи между сущностями
1. _User 1… House_* – через промежуточную таблицу UserHouse (many-to-many).
2. _House 1… Module_* – в одном доме может быть несколько модулей.
3. *_Module …1 ModuleType_ – каждый модуль принадлежит одному типу, тип используется многими модулями.
4. _Module 1… Device_* – модуль состоит из нескольких физических устройств.
5. *_Device …1 DeviceType_ – устройство соответствует конкретному типу.
6. _Device 1… TelemetryData_* – устройство генерирует множество записей телеметрии.
7. _Device 1… CommandLog_* – для одного устройства может быть много команд.

[ER диаграмма](diagrams/entity_relationship_diagram.puml)

# Задание 4. Создание и документирование API

### 1. Тип API
Синхронные операции «CRUD + команды» выполняются через REST API (OpenAPI ). 
Сервис: Device Management Service - Поток телеметрии и результатов команд передаётся асинхронно через RabbitMQ по AsyncAPI 2.6**. – Сервис-эмитент: **Telemetry Service** – Сервис-подписчик: **Device Management Service**, **Scenario Service** и др. Ниже два минимальных, но рабочих контракта: - 5 REST-эндпойнтов для управления устройствами; - 2 асинхронных канала для событий.

**REST API.** 
Для операций «спрос-ответ» ― регистрация устройства, чтение/изменение его параметров, отправка команды ― нужен мгновенный и однозначный результат (`200`, `404`, `422`). HTTP/REST обеспечивает именно такой короткий цикл: один запрос, один ответ, понятные методы (`GET`, `POST`, `PATCH`) и встроенные механизмы аутентификации через шлюз. Благодаря этому UI и другие сервисы сразу получают подтверждение, что действие выполнено или отклонено, без ожидания фоновых процессов.

**AsyncAPI (RabbitMQ).**
Телеметрия и результаты команд приходят потоками, причём сразу нескольким получателям (хранение, сценарии, аналитика). Передавать эти данные через опрос REST означало бы постоянный трафик и риск пропустить пики. Брокер событий решает проблему: устройства публикуют сообщения, а сервисы подписываются и обрабатывают их с нужной скоростью; сообщения буферизуются, не теряются при сбоях, и легко добавляется новый подписчик без изменения издателя.

### 2. Документация API

[Документация API для микросервисов](api/DeviceManagementAPI.yml)

# Задание 5. Работа с docker и docker-compose




